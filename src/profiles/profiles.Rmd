---
output: pdf_document
---
```{r setup, echo=FALSE, warning=FALSE, message=FALSE}
library(timeDate)
library(clValid)
library(knitr)
library(outliers)
library(plyr)
rm(list = ls())
options(error=traceback)
set.seed(1)

```





``` {r echo=FALSE, warning=FALSE}
####################### Carga de datos #########################

# Cargamos los datos de consumo
setwd("/home/andu/Documentos/uma/PHD/vatia/data/proc")
raw_data <- read.table("data.txt",sep="\t")
raw_meta <- read.table("meta.txt", sep="\t", encoding = "latin1")

list_hours <- colnames(raw_data)[!colnames(raw_data) %in% c("file_name","consumption_date")]
list_hours <- sapply(list_hours, function(s) { substr(s, 2, nchar(s))})

```


``` {r echo=FALSE, warning=FALSE}
####################### Funciones auxiliares #########################

# Definimos una función para convertir los datos de entrada en una lista de edificios
data_2_list <- function(data) {
  temp <- lapply(unique(data$file_name), function(s) {
    data[which(data$file_name == s),]
  })
  return(temp)
}


# Definimos una función para dividir un DF por mes
list_2_monthly_list <- function(list_dt) {
  dts <- unique(substr(list_dt$consumption_date,1,7))
  tmp <- lapply(dts, function(s) {
    list_dt[which( substr(list_dt$consumption_date,1,7)==s),]
  })
  return(tmp)
}


# Definimos una función auxiliar que retorna la moda estadística
val_mode <- function(x) {
  ux <- unique(x)
  ux[which.max(tabulate(match(x, ux)))]
}


# Función para "rellenar huecos" en un vector utilizando interpolación con una ventana móvil
namav <- function(x,k=3){
  x <- c(rep(NA, k),x,rep(NA,k)) # add NA on both sides
  n <- length(x)
  return(
    sapply((k+1):(n-k), function(i) { sum(x[(i-k):(i+k)],na.rm=TRUE)/(2*k+1-sum(is.na(x[(i-k):(i+k)]))) 
      })
  )
}

# A partir de un vector de coeficientes calcula el valor de la función en x
f_x <- function( poly, x) {
  facts <- sapply(1:length(poly), function(t) { (x**(t-1)) * poly[t] })
  return( sum(facts))
}

# Imprime el polinomio representado por el vector
f_x_print <- function( poly_lm, precision = 2 ) {
  poly <- extract_poly(poly_lm)
  facts <- lapply(1:length(poly), function(t) { 
    if(t>2) {
      paste( format(poly[t], digits=2, nsmall= precision),"x^", (t-1), sep="")
    } else {
      if(t>1) {
        paste( format(poly[t], digits=2, nsmall= precision),"x", sep="")
      } else {
        format(poly[t], digits=2, nsmall= precision)
      }
    }
  } )
    
  do.call(paste, c(facts, sep=" + "))
}

## A helper function that tests whether an object is either NULL _or_ 
## a list of NULLs
is.NullOb <- function(x) is.null(x) | all(sapply(x, is.null))

## Recursively step down into list, removing all such objects 
rmNullObs <- function(x) {
   x <- Filter(Negate(is.NullOb), x)
   lapply(x, function(x) if (is.list(x)) rmNullObs(x) else x)
}

```


``` {r echo=FALSE, warning=FALSE}
####################### Perfiles de carga #########################
# Función para el cálculo de la carga base temporal
base_load <- function(charge) {
  charge_matrix <- charge[,!colnames(charge) %in% c("file_name","consumption_date")]
  daily_min_charge <- sapply(1:nrow(charge_matrix), function(r) {min(charge_matrix[r,]) })
  if( length(daily_min_charge)==1 || sd(daily_min_charge)==0 ) { 
    outliers <- c() 
    dmc_wo <- daily_min_charge
  } else {  
    outliers <- outlier(daily_min_charge) 
    dmc_wo <- rm.outlier(daily_min_charge,fill=TRUE)
  }
  
  dmc_wo_stats <- list( min=min(dmc_wo), max=max(dmc_wo), mean=mean(dmc_wo), median=median(dmc_wo), sd=sd(dmc_wo))
  dmc_stats <- list( min=min(daily_min_charge), max=max(daily_min_charge), mean=mean(daily_min_charge), median=median(daily_min_charge), sd=sd(daily_min_charge))
  return( list(dmc=daily_min_charge, outliers=outliers, dmc_stats=dmc_stats, dmc_wo_stats=dmc_wo_stats))
}
```


``` {r echo=FALSE, warning=FALSE}
####################### Perfiles de carga #########################

# Generamos el calendario de festivos
sp_charvec <- c("2014-01-01","2014-01-06","2014-04-17", "2014-04-18", "2014-05-01", "2014-08-15", "2014-10-12", "2014-11-01", "2014-12-06", "2014-12-08", "2014-12-25"
                ,"2015-01-01","2015-01-06","2015-04-02", "2015-04-03", "2015-05-01", "2015-08-15", "2015-10-12", "2015-11-01", "2015-12-06", "2015-12-08", "2015-12-25"
                ,"2016-01-01","2016-01-06","2016-03-24", "2016-03-25", "2016-05-01", "2016-08-15", "2016-10-12", "2016-11-01", "2016-12-06", "2016-12-08", "2016-12-25")
sp_holidays <- timeDate(sp_charvec)

# Función que genera N clusters (donde N se escoge de manera automática utilizando métricas
# de validación interna) y grafica los centros. En cada gráfico se muestra el consumo
# y la carga base, donde la carga base se calcula como el consumo mínimo en el mes.
typical_profiles <- function(charge) {
  charge_matrix <- charge[,which(!colnames(charge) %in% c("file_name","consumption_date"))]
  # usando validación interna obtenemos el número óptimo de agrupaciones
  n_clust <- c(2:10)
  if(nrow(charge_matrix)<10) { n_clust <- c(2:(nrow(charge_matrix)-1))}
  iv <- clValid(charge_matrix, n_clust, clMethods=c("kmeans"), validation="internal")
  sel_measures <- c("Connectivity", "Dunn", "Silhouette")
  if(nrow(charge_matrix)<10) { 
    sel_measures <- c("Dunn", "Silhouette")
  } 
  os <- optimalScores(iv, measures = sel_measures)
  cl <- as.numeric(as.character(val_mode(os$Clusters)))
  km <- kmeans(charge_matrix, cl)
  
  # revisamos el calendario laborable
  biz_days <- isBizday(as.timeDate(charge$consumption_date), holidays = sp_holidays)
  biz_clus <- table(km$cluster[biz_days])
  holiday_clus <- table(km$cluster[!biz_days])
  
  return(list(centers = km$centers, clusters = km$cluster, size = km$size, biz_clus = biz_clus, holiday_clus = holiday_clus))
}

```


``` {r echo=FALSE, warning=FALSE}
####################### Aproximación analítica #########################

poly_model <- function(kmy, max_order = 5) {
  kmx <- 1:length(kmy)
  fits <- lapply( 1:max_order, function(s) { lm( formula = kmy ~ poly(kmx,s,raw=TRUE)) })
  anova_t <- do.call(anova, fits)
  fit_sel <- max(which(anova_t$`Pr(>F)` < 0.05 ))
  if(fit_sel < 1) {
    fit_sel <- length(fits)
  }
  return(fits[[ fit_sel ]])
}

extract_poly <- function( lm_model ) {
  sum <- summary.lm(lm_model)
  poly <- sum$coefficients[,1]
  names(poly) <- 0:(length(poly)-1)
  return(poly)
}

extract_rse <- function( lm_model ) {
  sum <- summary.lm(lm_model)
  return( sum$sigma )
}

```


``` {r echo=FALSE, warning=FALSE, results="asis", fig.width=5, fig.height=4, fig.align="center"}
# Función que para una lista de consumos retorna los perfiles típicos, carga base y las
# aproximaciones de los perfiles mediante polinomios
proc_charge <- function(nrgy_data, max_order = 6) {
  # Obtenemos los perfiles típicos de consumo
  profiles <- lapply( nrgy_data, function(tmp) {
    if(nrow(tmp)>1) {
      typical_profiles(tmp) 
    }
  })
  
  # Estimamos la carga base
  bls <- lapply( nrgy_data, function(tmp) {
    if(nrow(tmp)>1) {
      base_load(tmp) 
    }
  })
  
  # Aproximamos los perfiles típicos mediante polinomios
  poly_approxs <- lapply( profiles, function(tmp) {
    if(!is.null(tmp)) {
      polys <- list()
      for( index in 1:nrow(tmp$centers)) {
        pm <- poly_model(tmp$centers[index,], max_order = max_order)
        # polys[[index]] <- extract_poly(pm)
        polys[[index]] <- pm
      }
      polys
    }
  })
  
  return( list(profiles = profiles, base_load = bls, poly_approxs = poly_approxs))
}


# Convertimos los datos en una lista por edificio
list_data <- data_2_list(raw_data)
####################################
# Escogemos un edificio
s_meta <- 3

#s_meta <- 62
# Obtenemos el nombre del edificio (y lo arreglamos un poco)
building <- paste( toupper(substr(raw_meta[s_meta,c("name")], 1,1)), tolower(substr(raw_meta[s_meta,c("name")], 2,90)), sep="")
file_name <- raw_meta[s_meta, c("file_name")]
s <- 0
for(i in 1:length(list_data)) {
  if(unique(list_data[[i]]$file_name)==file_name) {
    s <- i
  }
}

# Imprimimos la cabecera
writeLines(paste("# ",building, sep=""))
writeLines("\n\n\n")
writeLines(paste("Fichero: ", file_name, sep=""))
writeLines("\n\n\n")

# Calculamos la carga base, los perfiles típicos y las aproximaciones analíticas 
############# MENSUAL ###############
writeLines("## Nivel de Agregación: Mensual")
writeLines("\n\n\n")
# Tomamos la información de la carga de dicho edificio y la agrupamos por mes
monthly_data <- list_2_monthly_list(list_data[[s]])
building_info <- proc_charge(monthly_data)


# building_info <- rmNullObs(building_info)
stats_bl <- t(sapply(rmNullObs(building_info$base_load), function(bl) { bl$dmc_wo_stats }))
stats_rn <- sapply( 1:length(building_info$base_load), function(i) { 
  if(!is.null(building_info$base_load[[i]])) {
    unique(substr(monthly_data[[i]]$consumption_date, 1,7))
  }
})
rownames(stats_bl) <- unlist(rmNullObs(stats_rn))
writeLines("Carga Base Estimada:")
kable(stats_bl, format.args = list(decimal.mark = ".") )

writeLines("\\newpage")

# Generamos las gráficas
for( i in 1:length(building_info$profiles) ) {
  if(!is.null(building_info$profiles[[i]])) {
    main_t <- unique(substr(monthly_data[[i]]$consumption_date, 1,7))
    writeLines(paste("## ", main_t, "\n", sep=""))
    p_sort <- sort(building_info$profiles[[i]]$size, decreasing = TRUE, index.return=TRUE)$ix
    pls <- lapply(p_sort , function(x) {
      max_load <- max(building_info$profiles[[i]]$centers) * 1.2
      ch <- building_info$profiles[[i]]$centers[x,] - building_info$base_load[[i]]$dmc_wo_stats$min
      bl <- rep(building_info$base_load[[i]]$dmc_wo_stats$min, length(ch))
      sub_t <- paste("Perfil ",x," de ",length(building_info$profiles[[i]]$size)," (",building_info$profiles[[i]]$size[x], " días)", sep="")
      # Barplot con la mínima como carga base
      bp <- barplot(as.table(rbind(bl,ch)), names.arg = list_hours, ylab="kWh", xlab="Hora", sub=sub_t, ylim=c(0,max_load))
      # Carga base Media 
      lines(x=bp,y=rep(building_info$base_load[[i]]$dmc_wo_stats$mean,length(bl)), col="blue", lwd=2)
      # Carga base Máx
      lines(x=bp,y=rep(building_info$base_load[[i]]$dmc_wo_stats$max,length(bl)), col="red", lwd=2)
      # Aproximación mediante un polinomio
      lines(x=bp,y=building_info$poly_approxs[[i]][[x]]$fitted.values, col="green", lty=2, lwd=2.5)
      # Leyenda del gráfico
      legend("topright", legend=c("Mín","Máx","Media","Poly"), bty="n", cex=0.8, col=c("black","red","blue","green"), pch=15, horiz=TRUE)
      writeLines("\n\n")
      writeLines(paste("Poly ",x,":",sep=""))
      writeLines( f_x_print(building_info$poly_approxs[[i]][[x]]) )
      writeLines( paste(" (RSE=", format(extract_rse(building_info$poly_approxs[[i]][[x]]), digits=2, nsmall=2) ,")",sep=""))
      writeLines("\n\n\n\n")
    } )
    clus_matrix <- rbind.fill.matrix(t(building_info$profiles[[i]]$biz_clus), t(building_info$profiles[[i]]$holiday_clus))
    clus_matrix[is.na(clus_matrix)] <- 0
    rownames(clus_matrix) <- c("Laborable", "No laborable")
    #writeLines("Clasificación de perfiles típicos por cluster")
    print(kable(clus_matrix))
    cat("\n")
    writeLines("\\newpage")
  }
}


############# ANUAL ###############
writeLines("## Nivel de Agregación: Anual")
writeLines("\n\n\n")
y_building_info <- proc_charge(list_data[s])
y_stats_bl <- t(sapply(rmNullObs(y_building_info$base_load), function(bl) { bl$dmc_wo_stats }))
rownames(y_stats_bl) <- c("Anual")
writeLines("Carga Base Estimada:")
kable(y_stats_bl, format.args = list(decimal.mark = ".") )

i <- 1
for( x in 1:nrow(y_building_info$profiles[[i]]$centers) ) {
  max_load <- max(y_building_info$profiles[[i]]$centers) * 1.2
  ch <- y_building_info$profiles[[i]]$centers[x,] - y_building_info$base_load[[i]]$dmc_wo_stats$min
  bl <- rep(y_building_info$base_load[[i]]$dmc_wo_stats$min, length(ch))
  sub_t <- paste("Perfil ",x," de ",length(y_building_info$profiles[[i]]$size)," (",y_building_info$profiles[[i]]$size[x], " días)", sep="")
  # Barplot con la mínima como carga base
  bp <- barplot(as.table(rbind(bl,ch)), names.arg = list_hours, ylab="kWh", xlab="Hora", sub=sub_t, ylim=c(0,max_load))
  # Carga base Media 
  lines(x=bp,y=rep(y_building_info$base_load[[i]]$dmc_wo_stats$mean,length(bl)), col="blue", lwd=2)
  # Carga base Máx
  lines(x=bp,y=rep(y_building_info$base_load[[i]]$dmc_wo_stats$max,length(bl)), col="red", lwd=2)
  # Aproximación mediante un polinomio
  #apr <- sapply(1:length(bp), function(t) {f_x(y_building_info$poly_approxs[[i]][[x]], t)})
  #lines(x=bp,y=apr, col="green", lty=2, lwd=2.5)
  lines(x=bp,y=y_building_info$poly_approxs[[i]][[x]]$fitted.values, col="green", lty=2, lwd=2.5)
  # Leyenda del gráfico
  legend("topright", legend=c("Mín","Máx","Media","Poly"), bty="n", cex=0.8, col=c("black","red","blue","green"), pch=15, horiz=TRUE)
  writeLines("\n\n")
  writeLines(paste("Poly ",x,":",sep=""))
  writeLines( f_x_print(y_building_info$poly_approxs[[i]][[x]]) )
  writeLines( paste(" (RSE=", format(extract_rse(y_building_info$poly_approxs[[i]][[x]]), digits=2, nsmall=2),")",sep=""))
  writeLines("\n\n\n\n")
}
clus_matrix <- rbind.fill.matrix(t(y_building_info$profiles[[i]]$biz_clus), t(y_building_info$profiles[[i]]$holiday_clus))
clus_matrix[is.na(clus_matrix)] <- 0
rownames(clus_matrix) <- c("Laborable", "No laborable")
#writeLines("Clasificación de perfiles típicos por cluster")
print(kable(clus_matrix))
cat("\n")


#tmp <- monthly_data[[1]]
#tmp <- tmp[,which(!colnames(monthly_data[[1]]) %in% c("file_name","consumption_date"))]
#tmp_lim <- c(0,max(tmp))
#lapply(1:nrow(tmp), function(j) {
#  plot(1:96,tmp[j,], type="l", xlab="", ylab="", ylim=tmp_lim)
#})
```

``` {r echo=FALSE, warning=FALSE, results="asis", fig.width=6.2, fig.height=1.5, fig.align="left"} 
writeLines("\\newpage")
writeLines("## Resumen Anual")
# Resumen de perfiles
max_p <- 3
max_load <- 1
for( i in 1:length(building_info$profiles) ) {
  if( length(building_info$profiles[[i]]$size) > max_p ) {
    max_p <- length(building_info$profiles[[i]]$size)
  }
  if( max(building_info$profiles[[i]]$centers) > max_load) {
    max_load <- max(building_info$profiles[[i]]$centers)
  }
}
max_load <- max_load*1.1

par(mfrow=c(1,max_p), mar=c(3.5,3.5,2,1), mgp=c(0.4, 0.4,0))
for( i in 1:length(building_info$profiles) ) {
   if(!is.null(building_info$profiles[[i]])) {
     main_t <- unique(substr(monthly_data[[i]]$consumption_date, 1,7))
     p_sort <- sort(building_info$profiles[[i]]$size, decreasing = TRUE, index.return=TRUE)$ix
     lapply(p_sort, function(x) {
       sub_t <- paste("Perfil ",x," de ",length(building_info$profiles[[i]]$size)," (",building_info$profiles[[i]]$size[x], " días)", sep="")
       plot(1:length(building_info$profiles[[i]]$centers[x,]),  building_info$profiles[[i]]$centers[x,], type="l", ylab="", xlab="", xaxt="n", ylim=c(0,max_load), main=main_t, sub=sub_t)
     })
     if((max_p - length(p_sort)) > 0) {
      lapply( 1:(max_p - length(p_sort)), function(x) { plot.new() } )
     }
   }
}
par(mfrow=c(1,1))
```
