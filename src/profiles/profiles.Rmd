---
output: pdf_document
---
```{r setup, echo=FALSE, warning=FALSE, message=FALSE}
library(timeDate)
library(clValid)
library(knitr)
library(outliers)
library(plyr)
rm(list = ls())
options(error=traceback)
set.seed(1)

```





``` {r echo=FALSE, warning=FALSE}
####################### Carga de datos #########################

# Cargamos los datos de consumo
setwd("/home/andu/Documentos/uma/PHD/vatia/data/proc")
raw_data <- read.table("data.txt",sep="\t")
raw_meta <- read.table("meta.txt", sep="\t", encoding = "latin1")

list_hours <- colnames(raw_data)[!colnames(raw_data) %in% c("file_name","consumption_date")]
list_hours <- sapply(list_hours, function(s) { substr(s, 2, nchar(s))})

```


``` {r echo=FALSE, warning=FALSE}
####################### Funciones auxiliares #########################

# Definimos una función para convertir los datos de entrada en una lista de edificios
data_2_list <- function(data) {
  temp <- lapply(unique(data$file_name), function(s) {
    data[which(data$file_name == s),]
  })
  return(temp)
}


# Definimos una función para dividir un DF por mes
list_2_monthly_list <- function(list_dt) {
  dts <- unique(substr(list_dt$consumption_date,1,7))
  tmp <- lapply(dts, function(s) {
    list_dt[which( substr(list_dt$consumption_date,1,7)==s),]
  })
  return(tmp)
}


# Definimos una función auxiliar que retorna la moda estadística
val_mode <- function(x) {
  ux <- unique(x)
  ux[which.max(tabulate(match(x, ux)))]
}


# Función para "rellenar huecos" en un vector utilizando interpolación con una ventana móvil
namav <- function(x,k=3){
  x <- c(rep(NA, k),x,rep(NA,k)) # add NA on both sides
  n <- length(x)
  return(
    sapply((k+1):(n-k), function(i) { sum(x[(i-k):(i+k)],na.rm=TRUE)/(2*k+1-sum(is.na(x[(i-k):(i+k)]))) 
      })
  )
}

# A partir de un vector de coeficientes calcula el valor de la función en x
f_x <- function( poly, x) {
  facts <- sapply(1:length(poly), function(t) { (x**(t-1)) * poly[t] })
  return( sum(facts))
}

# Imprime el polinomio representado por el vector
f_x_print <- function( poly, precision = 2 ) {
  facts <- lapply(1:length(poly), function(t) { paste( format(poly[t], digits=2, nsmall= precision),"x^",t, sep="")} )
  do.call(paste, c(facts, sep=" + "))
}

## A helper function that tests whether an object is either NULL _or_ 
## a list of NULLs
is.NullOb <- function(x) is.null(x) | all(sapply(x, is.null))

## Recursively step down into list, removing all such objects 
rmNullObs <- function(x) {
   x <- Filter(Negate(is.NullOb), x)
   lapply(x, function(x) if (is.list(x)) rmNullObs(x) else x)
}

```


``` {r echo=FALSE, warning=FALSE}
####################### Perfiles de carga #########################
# Función para el cálculo de la carga base temporal
base_load <- function(charge) {
  charge_matrix <- charge[,!colnames(charge) %in% c("file_name","consumption_date")]
  daily_min_charge <- sapply(1:nrow(charge_matrix), function(r) {min(charge_matrix[r,]) })
  if( length(daily_min_charge)==1 || sd(daily_min_charge)==0 ) { 
    outliers <- c() 
    dmc_wo <- daily_min_charge
  } else {  
    outliers <- outlier(daily_min_charge) 
    dmc_wo <- rm.outlier(daily_min_charge,fill=TRUE)
  }
  
  dmc_wo_stats <- list( min=min(dmc_wo), max=max(dmc_wo), mean=mean(dmc_wo), median=median(dmc_wo), sd=sd(dmc_wo))
  dmc_stats <- list( min=min(daily_min_charge), max=max(daily_min_charge), mean=mean(daily_min_charge), median=median(daily_min_charge), sd=sd(daily_min_charge))
  return( list(dmc=daily_min_charge, outliers=outliers, dmc_stats=dmc_stats, dmc_wo_stats=dmc_wo_stats))
}
```


``` {r echo=FALSE, warning=FALSE}
####################### Perfiles de carga #########################

# Función que genera N clusters (donde N se escoge de manera automática utilizando métricas
# de validación interna) y grafica los centros. En cada gráfico se muestra el consumo
# y la carga base, donde la carga base se calcula como el consumo mínimo en el mes.
typical_profiles <- function(charge) {
  charge_matrix <- charge[,which(!colnames(charge) %in% c("file_name","consumption_date"))]
  # usando validación interna obtenemos el número óptimo de agrupaciones
  n_clust <- c(2:10)
  if(nrow(charge_matrix)<10) { n_clust <- c(2:(nrow(charge_matrix)-1))}
  iv <- clValid(charge_matrix, n_clust, clMethods=c("kmeans"), validation="internal")
  sel_measures <- c("Connectivity", "Dunn", "Silhouette")
  if(nrow(charge_matrix)<10) { 
    sel_measures <- c("Dunn", "Silhouette")
  } 
  os <- optimalScores(iv, measures = sel_measures)
  cl <- as.numeric(as.character(val_mode(os$Clusters)))
  km <- kmeans(charge_matrix, cl)
  
  # revisamos el calendario laborable
  biz_days <- isBizday(as.timeDate(charge$consumption_date))
  biz_clus <- table(km$cluster[biz_days])
  holiday_clus <- table(km$cluster[!biz_days])
  
  return(list(centers = km$centers, clusters = km$cluster, size = km$size, biz_clus = biz_clus, holiday_clus = holiday_clus))
}

```


``` {r echo=FALSE, warning=FALSE}
####################### Aproximación analítica #########################

poly_model <- function(kmy, max_order = 5) {
  kmx <- 1:length(kmy)
  fits <- lapply( 1:max_order, function(s) { lm( formula = kmy ~ poly(kmx,s,raw=TRUE)) })
  anova_t <- do.call(anova, fits)
  fit_sel <- max(which(anova_t$`Pr(>F)` < 0.05 ))
  return(fits[[fit_sel]])
}

extract_poly <- function( lm_model ) {
  sum <- summary.lm(lm_model)
  poly <- sum$coefficients[,1]
  names(poly) <- 0:(length(poly)-1)
  return(poly)
}

```


``` {r echo=FALSE, warning=FALSE, results="asis", fig.width=5, fig.height=4, fig.align="center"}
# Función que para una lista de consumos retorna los perfiles típicos, carga base y las
# aproximaciones de los perfiles mediante polinomios
proc_charge <- function(nrgy_data, max_order = 6) {
  # Obtenemos los perfiles típicos de consumo
  profiles <- lapply( nrgy_data, function(tmp) {
    if(nrow(tmp)>1) {
      typical_profiles(tmp) 
    }
  })
  
  # Estimamos la carga base
  bls <- lapply( nrgy_data, function(tmp) {
    if(nrow(tmp)>1) {
      base_load(tmp) 
    }
  })
  
  # Aproximamos los perfiles típicos mediante polinomios
  poly_approxs <- lapply( profiles, function(tmp) {
    if(!is.null(tmp)) {
      polys <- list()
      for( index in 1:nrow(tmp$centers)) {
        pm <- poly_model(tmp$centers[index,], max_order = max_order)
        polys[[index]] <- extract_poly(pm)
      }
      polys
    }
  })
  
  return( list(profiles = profiles, base_load = bls, poly_approxs = poly_approxs))
}


# Convertimos los datos en una lista por edificio
list_data <- data_2_list(raw_data)
# Escogemos un edificio
s <- 16
# Tomamos la información de la carga de dicho edificio y la agrupamos por mes
monthly_data <- list_2_monthly_list(list_data[[s]])
# Obtenemos el nombre del edificio (y lo arreglamos un poco)
building <- paste( toupper(substr(raw_meta$name[s], 1,1)), tolower(substr(raw_meta$name[s], 2,50)), sep="")
# Imprimimos la cabecera
writeLines(paste("# ",building, sep=""))
writeLines("\n\n\n")
writeLines(paste("Fichero: ", raw_meta$file_name[s], sep=""))
writeLines("\n\n\n")

writeLines("Nivel de Agregación: Mensual")
writeLines("\n\n\n")

# Calculamos la carga base, los perfiles típicos y las aproximaciones analíticas 
building_info <- proc_charge(monthly_data)
# building_info <- rmNullObs(building_info)
stats_bl <- t(sapply(rmNullObs(building_info$base_load), function(bl) { bl$dmc_wo_stats }))
stats_rn <- sapply( 1:length(building_info$base_load), function(i) { 
  if(!is.null(building_info$base_load[[i]])) {
    unique(substr(monthly_data[[i]]$consumption_date, 1,7))
  }
})
rownames(stats_bl) <- unlist(rmNullObs(stats_rn))
writeLines("Carga Base Estimada:")
kable(stats_bl, format.args = list(decimal.mark = ".") )


writeLines("\\newpage")

# Generamos las gráficas
for( i in 1:length(building_info$profiles) ) {
  if(!is.null(building_info$profiles[[i]])) {
    main_t <- unique(substr(monthly_data[[i]]$consumption_date, 1,7))
    writeLines(paste("## ", main_t, "\n", sep=""))
    for( x in 1:nrow(building_info$profiles[[i]]$centers) ) {
      max_load <- max(building_info$profiles[[i]]$centers) * 1.2
      ch <- building_info$profiles[[i]]$centers[x,] - building_info$base_load[[i]]$dmc_wo_stats$min
      bl <- rep(building_info$base_load[[i]]$dmc_wo_stats$min, length(ch))
      sub_t <- paste("Perfil ",x," de ",length(building_info$profiles[[i]]$size)," (",building_info$profiles[[i]]$size[x], " días)", sep="")
      # Barplot con la mínima como carga base
      bp <- barplot(as.table(rbind(bl,ch)), names.arg = list_hours, ylab="kWh", xlab="Hora", sub=sub_t, ylim=c(0,max_load))
      # Carga base Media 
      lines(x=bp,y=rep(building_info$base_load[[i]]$dmc_wo_stats$mean,length(bl)), col="blue")
      # Carga base Máx
      lines(x=bp,y=rep(building_info$base_load[[i]]$dmc_wo_stats$max,length(bl)), col="red")
      # Aproximación mediante un polinomio
      apr <- sapply(1:length(bp), function(t) {f_x(building_info$poly_approxs[[i]][[x]], t)})
      lines(x=bp,y=apr, col="green", lty=2)
      # Leyenda del gráfico
      legend("topright", legend=c("Mín","Máx","Media","Poly"), bty="n", cex=0.8, col=c("black","red","blue","green"), pch=15, horiz=TRUE)
      writeLines("\n\n")
      writeLines(paste("Poly ",x,":",sep=""))
      writeLines( f_x_print(building_info$poly_approxs[[i]][[x]]) )
      writeLines("\n\n\n\n")
    }
    clus_matrix <- rbind.fill.matrix(t(building_info$profiles[[i]]$biz_clus), t(building_info$profiles[[i]]$holiday_clus))
    clus_matrix[is.na(clus_matrix)] <- 0
    rownames(clus_matrix) <- c("Laborable", "No laborable")
    #writeLines("Clasificación de perfiles típicos por cluster")
    print(kable(clus_matrix))
    cat("\n")
    writeLines("\\newpage")
  }
}
```
