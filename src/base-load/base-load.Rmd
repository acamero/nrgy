---
output: pdf_document
---
```{r setup, echo=FALSE, warning=FALSE, message=FALSE}
#library(lubridate)
library(clValid)
library(RMySQL)
library(knitr)
rm(list = ls())
options(error=traceback)
set.seed(1)

```



# Estudio de Carga Base y Correlación de Variables Climatológicas

El siguiente estudio presenta la correlación de las variables climatológicas con el consumo eléctrico mensual. Además se presenta el consumo y la carga base mensual *representativo*, donde la carga base se calcula como el consumo mínimo del mes analizado, y los consumos *representativos* son obtenidos mediante la agrupación de los perfiles diarios de consumo en una cantidad óptima de grupos. Cabe señalar que el número óptimo de agrupaciones para cada mes se realiza utilizando métricas de validación interna (*Conectividad*, *Dunn* y *Silhoutte*).

``` {r echo=FALSE, warning=FALSE}
# Cargamos los datos de consumo
setwd("/home/andu/Documentos/uma/PHD/vatia/data/proc")
raw_data <- read.table("data.txt",sep="\t")
raw_meta <- read.table("meta.txt", sep="\t", encoding = "latin1")

list_hours <- colnames(raw_data)[!colnames(raw_data) %in% c("file_name","consumption_date")]
list_hours <- sapply(list_hours, function(s) { substr(s, 2, nchar(s))})

# Conexión a la BD
mydb = dbConnect(MySQL(), user='root', password='q1w2e3r4', dbname='vatia_fdm', host='localhost')
# Datos de temperatura
rs_temperature = dbSendQuery(mydb, "select * from vatia_fdm.vw_matrix_weather_temperature")
raw_temperature = fetch(rs_temperature, n=-1)
raw_temperature[raw_temperature==-99999] <- NA
# Datos de precipitaciones
rs_precipitation = dbSendQuery(mydb, "select * from vatia_fdm.vw_matrix_weather_precipitation")
raw_precipitation = fetch(rs_precipitation, n=-1)
raw_precipitation[raw_precipitation==-99999] <- NA
# Datos de viento
rs_wind = dbSendQuery(mydb, "select * from vatia_fdm.vw_matrix_weather_wind")
raw_wind = fetch(rs_wind, n=-1)
raw_wind[raw_wind==-99999] <- NA
# Datos de presión atmosférica
rs_pressure = dbSendQuery(mydb, "select * from vatia_fdm.vw_matrix_weather_pressure")
raw_pressure = fetch(rs_pressure, n=-1)
raw_pressure[raw_pressure==-99999] <- NA

```

``` {r echo=FALSE, warning=FALSE}
# Definimos una función para convertir los datos de entrada en una lista de edificios
data_2_list <- function(data, metadata) {
  temp <- lapply(1:nrow(metadata), function(s) {
    data[which(data$file_name == metadata$file_name[s]),]
  })
  return(temp)
}


# Definimos una función para dividir un DF por mes
list_2_monthly_list <- function(list_dt) {
  dts <- unique(substr(list_dt$consumption_date,1,7))
  tmp <- lapply(dts, function(s) {
    list_dt[which( substr(list_dt$consumption_date,1,7)==s),]
  })
  return(tmp)
}


# Definimos una función auxiliar que retorna la moda estadística
val_mode <- function(x) {
  ux <- unique(x)
  ux[which.max(tabulate(match(x, ux)))]
}


# Función para "rellenar huecos" en un vector utilizando interpolación con una ventana móvil
namav <- function(x,k=3){
  x <- c(rep(NA, k),x,rep(NA,k)) # add NA on both sides
  n <- length(x)
  return(
    sapply((k+1):(n-k), function(i) { sum(x[(i-k):(i+k)],na.rm=TRUE)/(2*k+1-sum(is.na(x[(i-k):(i+k)]))) 
      })
  )
}


# Función para calcular la correlación de una variable climatológica con la carga
# El periodo de cálculo tiene relación con la variable "charge" de entrada
monthly_weather_corr <- function(city_weather, charge) {
  # extraemos las fechas presentes en la información de carga
  dates <- unique(charge$consumption_date)
  # y para esas fechas obtenemos las variables climatológicas (y las guardamos como)
  # un vector
  weather_v <- as.vector( sapply( dates, function(d) { 
    as.numeric(city_weather[ which(city_weather$forecast_date==d),  which(!colnames(city_weather) %in% c("fk_weather_station_id", "forecast_date"))]) 
    })   )
  # rellenamos huecos para tener la mayor cantidad posible de información
  weather_v <- namav(weather_v)
  charge_v <- as.vector( sapply( dates, function(d) { 
    as.numeric(charge[which(charge$consumption_date==d), which(!colnames(charge) %in% c("file_name","consumption_date"))])
    }) )
  if(length(weather_v)==length(charge_v)) {
    corr <- cor(charge_v, weather_v, use="pairwise.complete.obs")
    return(corr)
  }
  return(NA)
}


# Función que genera N clusters (donde N se escoge de manera automática utilizando métricas
# de validación interna) y grafica los centros. En cada gráfico se muestra el consumo
# y la carga base, donde la carga base se calcula como el consumo mínimo en el mes.
monthly_charge <- function(m_data, building_name) {
  tmp <- m_data[,which(!colnames(m_data) %in% c("file_name","consumption_date"))]
  m_data_date <- unique(substr(m_data$consumption_date,1,7))
  baseload <- min(tmp)
  max_load <- max(tmp)
  if(is.na(baseload)) { baseload <- 0}
  iv <- clValid(tmp, 2:10, clMethods=c("kmeans"), validation="internal")
  os <- optimalScores(iv)
  cl <- as.numeric(as.character(val_mode(os$Clusters)))
  km <- kmeans(tmp, cl)
  par(mfrow=c(1,2), cex.main=0.7)
  bps <- sapply( 1:length(km$size), function(x) {
    ch <- km$centers[x,] - baseload
    bl <- rep(baseload, length(km$centers[x,]))
    #barplot(km$centers[x,], names.arg = list_hours, ylab="kW", xlab="Time")
    main_t <- paste(building_name,"  (", m_data_date,")", sep="")
    sub_t <- paste("Perfil ",x," de ",length(km$size)," (",km$size[x], " días)", sep="")
    barplot(as.table(rbind(bl,ch)), names.arg = list_hours, ylab="kW", xlab="Tiempo", sub=sub_t, main=main_t, ylim=c(0,max_load))
  })
  writeLines("\n\n")
  par(reset=TRUE)
  return(bps)
}

```

``` {r echo=FALSE, warning=FALSE, results="asis", kable}
# Y los convertimos en una lista
list_data <- data_2_list(raw_data,raw_meta)

# Escogemos para que edificios se ejecutará el programa


s <- 1
# Para el edificio "s"
progr <- function(s) {
  # Tomamos la información de la carga y la agrupamos por mes
  monthly_data <- list_2_monthly_list(list_data[[s]])
  
  # Obtenemos el nombre del edificio (y lo arreglamos un pocp)
  building <- paste( toupper(substr(raw_meta$name[s], 1,1)), tolower(substr(raw_meta$name[s], 2,50)), sep="")
  
  writeLines(paste("## Edificio: ", building, sep=""))
  building <- substr(building, 1,20)
  
  # Revisaremos la correlación con el clima
  fk_city <- raw_meta$fk_weather_forecast_id[s]
  city_temperature <- raw_temperature[which(raw_temperature$fk_weather_station_id==fk_city),]
  city_pp <- raw_precipitation[which(raw_precipitation$fk_weather_station_id==fk_city),]
  city_wind <- raw_wind[which(raw_wind$fk_weather_station_id==fk_city),]
  city_pressure <- raw_pressure[which(raw_pressure$fk_weather_station_id==fk_city),]
  
  temperature_corr <- sapply( monthly_data, function(tmp) {
    monthly_weather_corr(city_temperature, tmp)
  })
  
  pp_corr <- sapply( monthly_data, function(tmp) {
    monthly_weather_corr(city_pp, tmp)
  })
  
  wind_corr <- sapply( monthly_data, function(tmp) {
    monthly_weather_corr(city_wind, tmp)
  })
  
  pressure_corr <- sapply( monthly_data, function(tmp) {
    monthly_weather_corr(city_pressure, tmp)
  })
  
  months <- sapply( monthly_data, function(tmp) {
    unique( substr(tmp$consumption_date, 1,7) )
  })
  
  weather_corr <- matrix(c(temperature_corr,pp_corr, wind_corr, pressure_corr), ncol=4)
  colnames(weather_corr) <- c("Temperatura", "Precipitaciones", "Viento", "Presión Atm")
  rownames(weather_corr) <- months
  
  writeLines("### Correlación Consumo - Clima")
  print(kable(weather_corr))
  writeLines("\n")
  writeLines("### Perfiles de Consumo y Carga Base")
  # Generaremos las curvas de carga con línea base para cada mes
  bps <- lapply( monthly_data, function(tmp) {
    if(nrow(tmp)>1) {
      monthly_charge(tmp, building) 
    }
  })
  
}

progr(s)
```


